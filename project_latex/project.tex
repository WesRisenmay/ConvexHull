\documentclass{article}
\usepackage{amsmath, amsthm, amssymb, bm}
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{float}
\usepackage[top=2in, bottom=1.5in, left=1in, right=1in]{geometry}
\makeidx
\setlength\parindent{0pt} % Removes all indentation from paragraphs

\renewcommand{\labelenumi}{\alph{enumi}.} % Make numbering in the enumerate environment by letter rather than number (e.g. section 6)
\begin{document}
\input{./title_sheet.tex}
\tableofcontents{}
\vspace{10cm}
{
  \section{Objective}
  \section{ConvexHull Overview}
  \section{Algorithm Explaination}
  \subsection{Brute Force}
  \subsection{QuickHull}
  \section{Algorithm Implementation}
  \subsection{Brute Force}
  As the name implies the brute force solution to the convexhule problem is very straight forward, as shown below in Figure ~\ref{fig:bruteforce}.
  \begin{figure}[H]
    \includegraphics[width=16cm,height=17cm]{bruteforce.png}
    \caption{Brute Force Convex Hull}
    \label{fig:bruteforce}
  \end{figure} 
  \subsection{QuickHull}
  \section{Analysis of Time Complexity}
  \subsection{Brute Force}
  Our brute force implementation is composed of 3 loops, each of which iterates through every point in the input. The basic operation for our algorithm is calculating the determinant which occurs in the inner most loop.
  \begin{center}
    \begin{align*}
      C(n) &= \sum\limits_{i=1}^n \sum\limits_{i=1}^{n-1} \sum\limits_{i=1}^{n-2} 1 \\
      C(n) &= (n-2) \cdot \sum\limits_{i=1}^n \sum\limits_{i=1}^{n-1}1 \\ 
      C(n) &= (n-2)(n-1) \cdot \sum\limits_{i=1}^n 1 \\
      C(n) &= (n-2)(n-1)n \\
      C(n) &= n^3 - 3n^2 + 2n \\ \\
           &O(n^3 -3n^2 +2n) \\
           &\bm{O(n^3)}
    \end{align*}
  \end{center}
It's important to note that the calculations above do not take into account cases where we're able to break out of the inner loop early when we find points on either side of the line that is being tested.  This means that specific arrangement of points we get as input will play a role in how quickly the algorithm completes.  The best case should be a situation in which the points are completly random, we would quickly find a point that is not on the same side as the others and exit the loop early.  On the other hand the worst case situation should occur with ordered input where we don't find a point on the other side of the line until late in the loop.
  \subsection{QuickHull}
  QuickHull is a divide and conquer type algorithm so we will use the \textbf{general divide-and-conquer reoccurance} in conjunction with the Master Theorem to analyis it. \textit{[Levitin pg.171]}

  \begin{center}
    $T(n) = aT(n/b) + f(n)$
  \end{center}

  Where $a$ is the number of subsets needing to be solved, $b$ is is the size of each subset, and $f(n)$ is the amout of time it takes to divide $n$ into $n/b$i subsets. \\ \\

\textbf{Best Case (Using Master Theorem)}
\begin{center}
  \begin{align*}
    &a = b = 2 &&\text{[partition into two even subsets]} \\
    &f(n) = n &&\text{[iterate through every point to find pivot]} \\
    &f(n) \epsilon \Theta(n^1) &&\text{[so in our case $d=1$]} \\\\
    &\bm{T(n) = 2T(n/2) + n} \\
    &\bm{\Theta(n\log(n))} &&\text{[since $a=b^1$]} \\
  \end{align*}
\end{center}
\textbf{Worst Case (Backward Substitution)} 
\begin{center}
  \begin{align*}
    T(n) &= T(n-1) + c\cdot n &&\text{[all points on one side of pivot]} \\
    T(n) &= T(n-2) + c[(n-1) + n] \\
    T(n) &= T(n-3) + c[(n-3) + (n-2) + (n-1) + n] \\
    T(n) &= T(n-4) + c[(n-4) + (n-3) + (n-2) + (n-1) + n] \\
    T(n) &= T(n-i) + c\sum\limits_{j=0}^i (n-j) \\ 
    T(n) &= T(n-i) + c(n\sum\limits_{j=0}^i1 - \sum\limits_{j=0}^i j) &&\text{[sum rules]}\\ 
    T(n) &= T(n-i) + c(n(\sum\limits_{j=1}^i1 - 1)  - \sum\limits_{j=1}^i j) &&\text{[sum rules]}\\ 
    T(n) &= T(n-i) + c(n(i - 1)  - \frac{i(i-1)}{2}) &&\text{[known sums]}\\ 
    T(n) &= T(n-n) + c(n(n - 1)  - \frac{n(n-1)}{2}) &&\text{[substituting $i=n$, $T(0)=0$]}\\ 
    T(n) &= c(n^2 - n  - \frac{n^2-n)}{2}) \\ 
    T(n) &= c(\frac{n^2}{2} - \frac{n}{2}) &&\text{[partial fraction expansion]}\\ 
         &O(c(\frac{n^2}{2} - \frac{n}{2})) \\
         &\bm{O(n^2)} &&\text{[can ignore lower order terms/constants]} \\
  \end{align*}
\end{center}

  \subsection{Expected Outcome}
  \begin{figure}[H]
    \includegraphics[width=14cm,height=11cm]{analysis_plot.png}
    \caption{Time Efficiency Analysis}
    \label{fig:time_plot}
  \end{figure} 
  \section{Automated Testing}
  \subsection{Algorithm Correctness}
  When deciding on a strategy to test the correctness of our algorithm we had a few key criteria. We wanted to avoid repeating the steps used in our algorithms, we wanted to be able to use double precision so that we could test for correctness with circular data, and we wanted to use some well tested java libraries. These criteria brought us to the Polygon.contains method in the java.awt library, but the contains method only works on integers, and this would disable our ability to correctly test convex hulls that are in the shape of a circle. We then discovered the Path2D library which supports double precision and has a contains method. The challenge with using the Path2D library comes in building the convex hull. Building the hull requires adding points in the correct order so that each point you add draws the correct line as it would look in the given convex hull. In order to solve this problem we had to sort the convex hull in a circular way so that the path could be drawn clockwise around the convex hull.
  \begin{figure}[H]
    \includegraphics[width=14cm,height=11cm]{correctness_1.png}
    \caption{Circular Case}
    \label{fig:correctness_1}
  \end{figure} 
  The code above shows the algorithm for building an array that can be used to draw the convex hull clockwise. First we add the left most point of the convex hull in the first position of the circular array. We start with the left, right, top, and bottom points of the convex hull available, and we use those to add the top left and top right portions of the convex hull to a linked list. We then find the left most element of the list and place it into the next available position of the circular array while removing it from the list. We repeat that step until the list is empty, and add the right point to the next available position. A similar strategy is used to add the bottom portion of the convex hull to the circular array, but the loop portion adds the right most point to the array to continue adding points in the clockwise direction. The code below shows the construction of the convex hull using the Path2D cHull. The path starts with the left most point contained in the first position of the circular array. The rest of the list is iterated through and lines are drawn to each consecutive point. A line is then drawn from the final point in the array to the first point added using the closePath method. With the convex hull drawn we are able to iterate through all the points and make sure each point is contained in the convex hull.
  \begin{figure}[H]
    \includegraphics[width=14cm,height=7cm]{correctness_2.png}
    \caption{Circular Correctness Test}
    \label{fig:correctness_2}
  \end{figure} 


  \subsection{Data Generation}
  In order to accurately assess the efficiency of our algorithms we came up with two different ways to generate test data: circular points and random points. When given circular points the efficiency of quick hull should decrease significantly, because each time it draws a triangle and searches for points inside the triangle it will find nothing, so the convex hull would be the entire set of points. The random data generated would give closer to average case efficiency, because usually provided points would be closer to random distribution. In order to generate a circular set of points the function below received a count of how many points need to be generated. At the start of the loop degrees is set to 0, and is incremented by 360 divided by the total number of points so that the data will be distributed well around the circle. Each point is given an x value of the radius multiplied by the cos of the current value of degrees, and the y value is generated using the sin function. The random data is generated point by point and uses the Math.random function.

  \section{Results}
  \section{Conclusion}



  %----------------------------------------------------------------------------------------
  % BIBLIOGRAPHY
  %----------------------------------------------------------------------------------------

  \bibliographystyle{unsrt}

  \bibliography{sample}

  %----------------------------------------------------------------------------------------


\end{document}
